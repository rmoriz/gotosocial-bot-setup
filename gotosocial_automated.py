#!/usr/bin/env python3
"""
Automated GoToSocial Token Generator

This script provides a fully automated solution for creating GoToSocial applications
and obtaining OAuth access tokens without requiring manual browser interaction.

Key Features:
- Programmatic OAuth flow handling
- Automatic login and authorization
- CSRF token extraction and handling
- Comprehensive error handling and logging
- JSON credential storage
- Token verification

The script simulates browser behavior to:
1. Create a new application on the GoToSocial instance
2. Navigate to the OAuth authorization page
3. Handle login if required (with CSRF protection)
4. Submit authorization forms automatically
5. Extract authorization codes from responses
6. Exchange codes for access tokens
7. Verify tokens and save credentials

This is ideal for:
- Automated deployments and CI/CD pipelines
- Server-side bot setup without GUI
- Batch creation of multiple bot accounts
- Any scenario requiring zero manual interaction

Security Notes:
- Uses session management for proper cookie handling
- Extracts and includes CSRF tokens for form submissions
- Follows redirects appropriately during OAuth flow
- Validates all API responses before proceeding

Author: Generated by Rovo Dev (Claude 3.5 Sonnet)
License: MIT
"""

import argparse
import json
import requests
import sys
from typing import Dict, Optional, Any
from urllib.parse import urlencode, parse_qs, urlparse
import re

class AutomatedGoToSocialAuth:
    """
    Automated OAuth handler for GoToSocial instances.
    
    This class handles the complete OAuth flow programmatically, including:
    - Application creation
    - User authentication
    - Authorization form submission
    - Token exchange and verification
    
    The class maintains session state throughout the process to handle
    cookies, CSRF tokens, and redirects properly.
    
    Attributes:
        instance_url (str): The base URL of the GoToSocial instance
        app_name (str): Name of the application to create
        scopes (str): OAuth scopes to request (default: "read write")
        client_id (str): OAuth client ID (set after app creation)
        client_secret (str): OAuth client secret (set after app creation)
        redirect_uri (str): OAuth redirect URI (uses out-of-band flow)
        session (requests.Session): HTTP session for maintaining state
    """
    
    def __init__(self, instance_url: str, app_name: str, scopes: str = "read write") -> None:
        """
        Initialize the automated OAuth handler.
        
        Args:
            instance_url: The GoToSocial instance URL (e.g., "https://social.example.com")
            app_name: Name for the application to create
            scopes: OAuth scopes to request (default: "read write")
        """
        self.instance_url = instance_url.rstrip('/')
        self.app_name = app_name
        self.scopes = scopes
        self.client_id: Optional[str] = None
        self.client_secret: Optional[str] = None
        self.redirect_uri = "urn:ietf:wg:oauth:2.0:oob"
        self.session = requests.Session()
        
        # Set a reasonable user agent
        self.session.headers.update({
            'User-Agent': 'GoToSocial-Bot-Setup/1.0 (Automated OAuth Client)'
        })
        
    def create_application(self) -> Dict[str, Any]:
        """
        Create a new OAuth application on the GoToSocial instance.
        
        This method registers a new application with the GoToSocial instance,
        which is required before starting the OAuth flow. The application
        details are used to identify your bot and request appropriate permissions.
        
        Returns:
            Dict containing application data including client_id and client_secret
            
        Raises:
            SystemExit: If application creation fails
            
        Example response:
            {
                "client_id": "abc123...",
                "client_secret": "def456...",
                "name": "My Bot",
                "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
                "scopes": ["read", "write"]
            }
        """
        print(f"Creating application '{self.app_name}' on {self.instance_url}...")
        
        url = f"{self.instance_url}/api/v1/apps"
        data = {
            "client_name": self.app_name,
            "redirect_uris": self.redirect_uri,
            "scopes": self.scopes,
            "website": ""
        }
        
        try:
            response = self.session.post(url, data=data)
            response.raise_for_status()
            
            app_data = response.json()
            self.client_id = app_data["client_id"]
            self.client_secret = app_data["client_secret"]
            
            print("âœ“ Application created successfully!")
            return app_data
            
        except requests.exceptions.RequestException as e:
            print(f"âœ— Failed to create application: {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"  Response: {e.response.text}")
            sys.exit(1)
    
    def automated_authorize(self, username: str, password: str) -> Optional[str]:
        """
        Automatically handle the complete OAuth authorization flow.
        
        This method simulates browser behavior to:
        1. Navigate to the OAuth authorization page
        2. Detect if login is required
        3. Submit login credentials if needed
        4. Handle CSRF tokens and form submissions
        5. Extract the authorization code from the response
        
        The process handles various GoToSocial configurations including:
        - Instances requiring login before authorization
        - CSRF protection mechanisms
        - Different form field names and structures
        - Redirect-based and embedded code responses
        
        Args:
            username: User's login username or email address
            password: User's login password
            
        Returns:
            Authorization code string if successful, None if failed
            
        Note:
            This method maintains session state throughout the process,
            ensuring cookies and authentication persist across requests.
        """
        print("Starting automated authorization...")
        
        # Step 1: Get the authorization page
        auth_url = self.get_authorization_url()
        print(f"Getting authorization page: {auth_url}")
        
        try:
            # Get the authorization page
            response = self.session.get(auth_url)
            response.raise_for_status()
            
            # Check if we're already logged in or need to login
            if "Sign in" in response.text or "login" in response.text.lower():
                print("Need to log in first...")
                auth_code = self._handle_login_and_authorize(response, username, password)
            else:
                print("Already logged in, proceeding with authorization...")
                auth_code = self._extract_or_authorize(response)
            
            return auth_code
            
        except Exception as e:
            print(f"âœ— Automated authorization failed: {e}")
            return None
    
    def _handle_login_and_authorize(self, auth_response: requests.Response, username: str, password: str) -> Optional[str]:
        """
        Handle user login followed by OAuth authorization.
        
        This method is called when the authorization page indicates that
        user login is required before proceeding with OAuth authorization.
        
        Process:
        1. Navigate to the login page
        2. Extract CSRF tokens from login form
        3. Submit login credentials
        4. Verify successful login
        5. Retry authorization flow
        
        Args:
            auth_response: Initial authorization page response
            username: User's login credentials
            password: User's login credentials
            
        Returns:
            Authorization code if successful, None if login or authorization fails
        """
        
        # Look for login form
        login_url = f"{self.instance_url}/auth/sign_in"
        
        print(f"Attempting to log in at: {login_url}")
        
        # Get login page
        login_response = self.session.get(login_url)
        login_response.raise_for_status()
        
        # Extract CSRF token or other form data
        csrf_token = self._extract_csrf_token(login_response.text)
        
        # Prepare login data
        login_data = {
            "username": username,
            "password": password
        }
        
        if csrf_token:
            login_data["authenticity_token"] = csrf_token
        
        # Submit login
        login_submit_response = self.session.post(login_url, data=login_data, allow_redirects=True)
        
        if login_submit_response.status_code == 200 and "Sign in" not in login_submit_response.text:
            print("âœ“ Login successful!")
            
            # Now try the authorization again
            auth_url = self.get_authorization_url()
            auth_response = self.session.get(auth_url)
            auth_response.raise_for_status()
            
            return self._extract_or_authorize(auth_response)
        else:
            print("âœ— Login failed!")
            print(f"Response status: {login_submit_response.status_code}")
            return None
    
    def _extract_csrf_token(self, html_content: str) -> Optional[str]:
        """
        Extract CSRF token from HTML content.
        
        GoToSocial instances often use CSRF protection for forms. This method
        searches for CSRF tokens using common patterns found in web frameworks.
        
        Supported token patterns:
        - authenticity_token (Rails-style)
        - csrf_token (generic)
        - _token (Laravel-style)
        - Meta tag csrf-token (SPA-style)
        
        Args:
            html_content: HTML content to search for CSRF tokens
            
        Returns:
            CSRF token string if found, None otherwise
        """
        # Look for CSRF token in various forms
        patterns = [
            r'name="authenticity_token"[^>]*value="([^"]*)"',
            r'name="csrf_token"[^>]*value="([^"]*)"',
            r'name="_token"[^>]*value="([^"]*)"',
            r'<meta name="csrf-token" content="([^"]*)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html_content)
            if match:
                return match.group(1)
        
        return None
    
    def _extract_or_authorize(self, auth_response: requests.Response) -> Optional[str]:
        """
        Extract authorization code from response or submit authorization form.
        
        This method handles the final step of OAuth authorization by either:
        1. Extracting an authorization code if already present in the response
        2. Submitting the authorization form to grant permissions
        
        The method handles various response formats:
        - Direct code in URL parameters
        - Code embedded in HTML content
        - Authorization forms requiring submission
        - Redirect responses with code in Location header
        
        Args:
            auth_response: Response from authorization page
            
        Returns:
            Authorization code string if successful, None if extraction fails
        """
        
        # Check if there's already an authorization code in the response
        if "authorization_code" in auth_response.text or "code=" in auth_response.text:
            # Try to extract the code directly
            code_match = re.search(r'code=([^&\s"]+)', auth_response.text)
            if code_match:
                return code_match.group(1)
        
        # Look for authorization form to submit
        if "authorize" in auth_response.text.lower() or "allow" in auth_response.text.lower():
            print("Found authorization form, submitting...")
            
            # Extract form data
            csrf_token = self._extract_csrf_token(auth_response.text)
            
            # Submit authorization
            auth_data = {
                "client_id": self.client_id,
                "redirect_uri": self.redirect_uri,
                "response_type": "code",
                "scope": self.scopes
            }
            
            if csrf_token:
                auth_data["authenticity_token"] = csrf_token
            
            # Submit the authorization
            auth_submit_url = f"{self.instance_url}/oauth/authorize"
            auth_submit_response = self.session.post(auth_submit_url, data=auth_data, allow_redirects=False)
            
            # Check for redirect with code
            if auth_submit_response.status_code in [302, 303]:
                location = auth_submit_response.headers.get('Location', '')
                if 'code=' in location:
                    parsed = urlparse(location)
                    query_params = parse_qs(parsed.query)
                    if 'code' in query_params:
                        return query_params['code'][0]
            
            # Check response text for code
            if 'code=' in auth_submit_response.text:
                code_match = re.search(r'code=([^&\s"]+)', auth_submit_response.text)
                if code_match:
                    return code_match.group(1)
        
        print("âœ— Could not extract authorization code")
        return None
    
    def get_authorization_url(self) -> str:
        """
        Generate the OAuth authorization URL.
        
        Constructs the URL that users would normally visit in their browser
        to authorize the application. This URL includes all necessary OAuth
        parameters for the authorization code flow.
        
        Returns:
            Complete authorization URL with encoded parameters
            
        Example:
            https://social.example.com/oauth/authorize?client_id=abc123&redirect_uri=urn:ietf:wg:oauth:2.0:oob&response_type=code&scope=read+write
        """
        params = {
            "client_id": self.client_id,
            "redirect_uri": self.redirect_uri,
            "response_type": "code",
            "scope": self.scopes
        }
        
        auth_url = f"{self.instance_url}/oauth/authorize?" + urlencode(params)
        return auth_url
    
    def get_access_token(self, authorization_code: str) -> Dict[str, Any]:
        """
        Exchange authorization code for an access token.
        
        This is the final step of the OAuth flow where the temporary
        authorization code is exchanged for a permanent access token
        that can be used to make API calls.
        
        Args:
            authorization_code: The authorization code obtained from the authorization step
            
        Returns:
            Dictionary containing token data including access_token, token_type, scope, etc.
            
        Raises:
            SystemExit: If token exchange fails
            
        Example response:
            {
                "access_token": "xyz789...",
                "token_type": "Bearer",
                "scope": "read write",
                "created_at": 1640995200
            }
        """
        print("Exchanging authorization code for access token...")
        
        url = f"{self.instance_url}/oauth/token"
        data = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "redirect_uri": self.redirect_uri,
            "grant_type": "authorization_code",
            "code": authorization_code,
            "scope": self.scopes
        }
        
        try:
            response = self.session.post(url, data=data)
            response.raise_for_status()
            
            token_data = response.json()
            print("âœ“ Access token generated successfully!")
            return token_data
            
        except requests.exceptions.RequestException as e:
            print(f"âœ— Failed to get access token: {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"  Response: {e.response.text}")
            sys.exit(1)
    
    def verify_token(self, access_token: str) -> Optional[Dict[str, Any]]:
        """
        Verify the access token by making a test API call.
        
        Tests the newly obtained access token by calling the verify_credentials
        endpoint. This confirms that the token is valid and returns information
        about the authenticated account.
        
        Args:
            access_token: The access token to verify
            
        Returns:
            Dictionary containing account information if successful, None if verification fails
            
        Example response:
            {
                "id": "123",
                "username": "mybot",
                "display_name": "My Bot",
                "acct": "mybot@social.example.com",
                "url": "https://social.example.com/@mybot",
                ...
            }
        """
        print("Verifying access token...")
        
        url = f"{self.instance_url}/api/v1/accounts/verify_credentials"
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = self.session.get(url, headers=headers)
            response.raise_for_status()
            
            account_data = response.json()
            print("âœ“ Token verification successful!")
            print(f"  Account: @{account_data.get('username', 'unknown')}")
            print(f"  Display Name: {account_data.get('display_name', 'N/A')}")
            
            return account_data
            
        except requests.exceptions.RequestException as e:
            print(f"âœ— Token verification failed: {e}")
            return None
    
    def save_credentials(self, app_data: Dict[str, Any], token_data: Dict[str, Any], 
                        account_data: Dict[str, Any], filename: str) -> Optional[str]:
        """
        Save all credentials and metadata to a JSON file.
        
        Creates a comprehensive credentials file containing all information
        needed to use the bot, including application details, tokens, and
        account information.
        
        Args:
            app_data: Application information from create_application()
            token_data: Token information from get_access_token()
            account_data: Account information from verify_token()
            filename: Path where to save the credentials file
            
        Returns:
            Filename if successful, None if save failed
            
        File structure:
            {
                "instance_url": "https://social.example.com",
                "app_name": "My Bot",
                "client_id": "abc123...",
                "client_secret": "def456...",
                "access_token": "xyz789...",
                "token_type": "Bearer",
                "scope": "read write",
                "account": { ... },
                "app_data": { ... },
                "token_data": { ... }
            }
        """
        credentials = {
            "instance_url": self.instance_url,
            "app_name": self.app_name,
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "access_token": token_data["access_token"],
            "token_type": token_data.get("token_type", "Bearer"),
            "scope": token_data.get("scope", self.scopes),
            "created_at": token_data.get("created_at"),
            "account": account_data,
            "app_data": app_data,
            "token_data": token_data
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(credentials, f, indent=2)
            print(f"âœ“ Credentials saved to: {filename}")
            return filename
        except Exception as e:
            print(f"âœ— Failed to save credentials: {e}")
            return None

def automated_setup(instance_url: str, app_name: str, username: str, password: str, 
                   output_file: Optional[str] = None) -> Dict[str, Any]:
    """
    Complete automated setup for GoToSocial bot authentication.
    
    This is the main entry point for automated bot setup. It orchestrates
    the entire process from application creation to token verification,
    providing a simple interface for getting a working bot token.
    
    Process:
    1. Create OAuth application on the instance
    2. Perform automated login and authorization
    3. Exchange authorization code for access token
    4. Verify token functionality
    5. Save credentials to file (if specified)
    
    Args:
        instance_url: GoToSocial instance URL (e.g., "https://social.example.com")
        app_name: Name for the bot application
        username: User's login username or email
        password: User's login password
        output_file: Optional path to save credentials JSON file
        
    Returns:
        Dictionary containing all credentials and metadata
        
    Raises:
        SystemExit: If any step of the process fails
        
    Example:
        result = automated_setup(
            "https://social.example.com",
            "Weather Bot",
            "myuser",
            "mypassword",
            "weather_bot.json"
        )
        print(f"Bot token: {result['access_token']}")
    """
    
    auth = AutomatedGoToSocialAuth(instance_url, app_name)
    
    # Step 1: Create application
    app_data = auth.create_application()
    
    # Step 2: Automated authorization
    auth_code = auth.automated_authorize(username, password)
    
    if not auth_code:
        print("âœ— Failed to get authorization code")
        sys.exit(1)
    
    print(f"âœ“ Got authorization code: {auth_code[:10]}...")
    
    # Step 3: Get access token
    token_data = auth.get_access_token(auth_code)
    
    # Step 4: Verify token
    account_data = auth.verify_token(token_data["access_token"])
    
    # Step 5: Save credentials
    if output_file:
        auth.save_credentials(app_data, token_data, account_data, output_file)
    
    result = {
        "instance_url": instance_url,
        "app_name": app_name,
        "access_token": token_data["access_token"],
        "client_id": auth.client_id,
        "client_secret": auth.client_secret,
        "account": account_data,
        "app_data": app_data,
        "token_data": token_data
    }
    
    print(f"\nðŸŽ‰ SUCCESS! Your access token: {token_data['access_token']}")
    print(f"Account: @{account_data['username']}")
    
    return result

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Automated GoToSocial token generator")
    parser.add_argument("--instance", required=True, help="GoToSocial instance URL")
    parser.add_argument("--app-name", required=True, help="Application name")
    parser.add_argument("--username", required=True, help="Your username/email")
    parser.add_argument("--password", required=True, help="Your password")
    parser.add_argument("--output", help="Output file for credentials")
    parser.add_argument("--scopes", default="read write", help="OAuth scopes")
    
    args = parser.parse_args()
    
    try:
        result = automated_setup(
            args.instance,
            args.app_name,
            args.username,
            args.password,
            args.output
        )
        
    except Exception as e:
        print(f"âœ— Error: {e}")
        sys.exit(1)